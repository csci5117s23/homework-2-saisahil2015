"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildClerkProps = exports.getAuth = void 0;
const backend_1 = require("@clerk/backend");
const clerk_1 = require("./clerk");
const utils_1 = require("./utils");
const getAuth = (req, opts) => {
    // When the auth status is set, we trust that the middleware has already run
    // Then, we don't have to re-verify the JWT here,
    // we can just strip out the claims manually.
    const authStatus = (0, utils_1.getAuthKeyFromRequest)(req, 'AuthStatus');
    const authMessage = (0, utils_1.getAuthKeyFromRequest)(req, 'AuthMessage');
    const authReason = (0, utils_1.getAuthKeyFromRequest)(req, 'AuthReason');
    if (!authStatus) {
        throw new Error('You need to use "withClerkMiddleware" in your Next.js middleware file. You also need to make sure that your middleware matcher is configured correctly and matches this route or page. See https://clerk.com/docs/quickstarts/get-started-with-nextjs');
    }
    const options = {
        apiKey: opts?.apiKey || clerk_1.API_KEY,
        secretKey: opts?.secretKey || clerk_1.SECRET_KEY,
        apiUrl: clerk_1.API_URL,
        apiVersion: clerk_1.API_VERSION,
        authStatus,
        authMessage,
        authReason,
    };
    if (authStatus !== backend_1.AuthStatus.SignedIn) {
        return (0, backend_1.signedOutAuthObject)(options);
    }
    const jwt = parseJwt(req);
    return (0, backend_1.signedInAuthObject)(jwt.payload, { ...options, token: jwt.raw.text });
};
exports.getAuth = getAuth;
const buildClerkProps = (req, initState = {}) => {
    const authStatus = (0, utils_1.getAuthKeyFromRequest)(req, 'AuthStatus');
    const authMessage = (0, utils_1.getAuthKeyFromRequest)(req, 'AuthMessage');
    const authReason = (0, utils_1.getAuthKeyFromRequest)(req, 'AuthReason');
    const options = {
        apiKey: clerk_1.API_KEY,
        secretKey: clerk_1.SECRET_KEY,
        apiUrl: clerk_1.API_URL,
        apiVersion: clerk_1.API_VERSION,
        authStatus,
        authMessage,
        authReason,
    };
    let authObject;
    if (!authStatus || authStatus !== backend_1.AuthStatus.SignedIn) {
        authObject = (0, backend_1.signedOutAuthObject)(options);
    }
    else {
        const { payload, raw } = parseJwt(req);
        authObject = (0, backend_1.signedInAuthObject)(payload, { ...options, token: raw.text });
    }
    const sanitizedAuthObject = (0, backend_1.makeAuthObjectSerializable)((0, backend_1.sanitizeAuthObject)({ ...authObject, ...initState }));
    return (0, utils_1.injectSSRStateIntoObject)({}, sanitizedAuthObject);
};
exports.buildClerkProps = buildClerkProps;
const parseJwt = (req) => {
    const cookieToken = (0, utils_1.getCookie)(req, backend_1.constants.Cookies.Session);
    const headerToken = (0, utils_1.getHeader)(req, 'authorization')?.replace('Bearer ', '');
    return (0, backend_1.decodeJwt)(cookieToken || headerToken || '');
};
