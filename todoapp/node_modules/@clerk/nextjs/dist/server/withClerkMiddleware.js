"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleMiddlewareResult = exports.withClerkMiddleware = exports.decorateResponseWithObservabilityHeaders = void 0;
const backend_1 = require("@clerk/backend");
const server_1 = require("next/server");
const constants_1 = require("../constants");
const clerk_1 = require("./clerk");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
const decorateResponseWithObservabilityHeaders = (res, requestState) => {
    requestState.message && res.headers.set(backend_1.constants.Headers.AuthMessage, encodeURIComponent(requestState.message));
    requestState.reason && res.headers.set(backend_1.constants.Headers.AuthReason, encodeURIComponent(requestState.reason));
    requestState.status && res.headers.set(backend_1.constants.Headers.AuthStatus, encodeURIComponent(requestState.status));
};
exports.decorateResponseWithObservabilityHeaders = decorateResponseWithObservabilityHeaders;
const withClerkMiddleware = (...args) => {
    const noop = () => undefined;
    const [handler = noop, opts = {}] = args;
    const proxyUrl = opts?.proxyUrl || clerk_1.PROXY_URL;
    if (!!proxyUrl && !(0, utils_1.isHttpOrHttps)(proxyUrl)) {
        throw new Error(errors_1.unsupportedRelativePathProxyUrl);
    }
    return async (req, event) => {
        const { headers } = req;
        const isSatellite = (0, utils_1.handleValueOrFn)(opts.isSatellite, new URL(req.url), clerk_1.IS_SATELLITE);
        const domain = (0, utils_1.handleValueOrFn)(opts.domain, new URL(req.url), clerk_1.DOMAIN);
        const signInUrl = opts?.signInUrl || clerk_1.SIGN_IN_URL;
        if (isSatellite && !proxyUrl && !domain) {
            throw new Error(errors_1.missingDomainAndProxy);
        }
        if (isSatellite && !(0, utils_1.isHttpOrHttps)(signInUrl) && (0, utils_1.isDevelopmentFromApiKey)(clerk_1.SECRET_KEY || clerk_1.API_KEY)) {
            throw new Error(errors_1.missingSignInUrlInDev);
        }
        // get auth state, check if we need to return an interstitial
        const cookieToken = (0, utils_1.getCookie)(req, backend_1.constants.Cookies.Session);
        const headerToken = headers.get('authorization')?.replace('Bearer ', '');
        const requestState = await clerk_1.clerkClient.authenticateRequest({
            ...opts,
            apiKey: opts.apiKey || clerk_1.API_KEY,
            secretKey: opts.secretKey || clerk_1.SECRET_KEY,
            frontendApi: opts.frontendApi || clerk_1.FRONTEND_API,
            publishableKey: opts.publishableKey || clerk_1.PUBLISHABLE_KEY,
            cookieToken,
            headerToken,
            clientUat: (0, utils_1.getCookie)(req, backend_1.constants.Cookies.ClientUat),
            origin: headers.get('origin') || undefined,
            host: headers.get('host'),
            forwardedPort: headers.get('x-forwarded-port') || undefined,
            forwardedHost: headers.get('x-forwarded-host') || undefined,
            referrer: headers.get('referer') || undefined,
            userAgent: headers.get('user-agent') || undefined,
            proxyUrl,
            isSatellite,
            domain,
            searchParams: new URL(req.url).searchParams,
            signInUrl,
        });
        // Interstitial case
        // Note: there is currently no way to rewrite to a protected endpoint
        // Therefore we have to resort to a public interstitial endpoint
        if (requestState.isUnknown) {
            const response = new server_1.NextResponse(null, { status: 401, headers: { 'Content-Type': 'text/html' } });
            (0, exports.decorateResponseWithObservabilityHeaders)(response, requestState);
            return response;
        }
        if (requestState.isInterstitial) {
            const response = server_1.NextResponse.rewrite(clerk_1.clerkClient.remotePublicInterstitialUrl({
                apiUrl: clerk_1.API_URL,
                frontendApi: opts.frontendApi || clerk_1.FRONTEND_API,
                publishableKey: opts.publishableKey || clerk_1.PUBLISHABLE_KEY,
                pkgVersion: clerk_1.JS_VERSION,
                proxyUrl: requestState.proxyUrl,
                isSatellite: requestState.isSatellite,
                domain: requestState.domain,
                debugData: (0, backend_1.debugRequestState)(requestState),
                signInUrl: requestState.signInUrl,
            }), { status: 401 });
            (0, exports.decorateResponseWithObservabilityHeaders)(response, requestState);
            return response;
        }
        // Set auth result on request in a private property so that middleware can read it too
        (0, utils_1.setCustomAttributeOnRequest)(req, backend_1.constants.Attributes.AuthStatus, requestState.status);
        (0, utils_1.setCustomAttributeOnRequest)(req, backend_1.constants.Attributes.AuthMessage, requestState.message || '');
        (0, utils_1.setCustomAttributeOnRequest)(req, backend_1.constants.Attributes.AuthReason, requestState.reason || '');
        // get result from provided handler
        const res = await handler(req, event);
        const { status: authStatus, reason: authReason, message: authMessage } = requestState;
        return handleMiddlewareResult({ req, res, authStatus, authReason, authMessage });
    };
};
exports.withClerkMiddleware = withClerkMiddleware;
// Auth result will be set as both a query param & header when applicable
function handleMiddlewareResult({ req, res, authStatus, authMessage, authReason, }) {
    // pass-through case, convert to next()
    if (!res) {
        res = server_1.NextResponse.next();
    }
    // redirect() case, return early
    if (res.headers.get(constants_1.constants.Headers.NextRedirect)) {
        return res;
    }
    let rewriteURL;
    // next() case, convert to a rewrite
    if (res.headers.get(constants_1.constants.Headers.NextResume) === '1') {
        res.headers.delete(constants_1.constants.Headers.NextResume);
        rewriteURL = new URL(req.url);
    }
    // rewrite() case, set auth result only if origin remains the same
    const rewriteURLHeader = res.headers.get(constants_1.constants.Headers.NextRewrite);
    if (rewriteURLHeader) {
        const reqURL = new URL(req.url);
        rewriteURL = new URL(rewriteURLHeader);
        // if the origin has changed, return early
        if (rewriteURL.origin !== reqURL.origin) {
            return res;
        }
    }
    if (rewriteURL) {
        if ((0, utils_1.nextJsVersionCanOverrideRequestHeaders)()) {
            // If we detect that the host app is using a nextjs installation that reliably sets the
            // request headers, we don't need to fall back to the searchParams strategy.
            // In this case, we won't set them at all in order to avoid having them visible in the req.url
            (0, utils_1.setRequestHeadersOnNextResponse)(res, req, {
                [backend_1.constants.Headers.AuthStatus]: authStatus,
                [backend_1.constants.Headers.AuthMessage]: authMessage || '',
                [backend_1.constants.Headers.AuthReason]: authReason || '',
            });
        }
        else {
            res.headers.set(backend_1.constants.Headers.AuthStatus, authStatus);
            res.headers.set(backend_1.constants.Headers.AuthMessage, authMessage || '');
            res.headers.set(backend_1.constants.Headers.AuthReason, authReason || '');
            rewriteURL.searchParams.set(backend_1.constants.SearchParams.AuthStatus, authStatus);
            rewriteURL.searchParams.set(backend_1.constants.Headers.AuthMessage, authMessage || '');
            rewriteURL.searchParams.set(backend_1.constants.Headers.AuthReason, authReason || '');
        }
        res.headers.set(constants_1.constants.Headers.NextRewrite, rewriteURL.href);
    }
    return res;
}
exports.handleMiddlewareResult = handleMiddlewareResult;
