"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDevelopmentFromApiKey = exports.isHttpOrHttps = exports.handleValueOrFn = exports.injectSSRStateIntoObject = exports.nextJsVersionCanOverrideRequestHeaders = exports.setRequestHeadersOnNextResponse = exports.getCookie = exports.getHeader = exports.getAuthStatusFromRequest = exports.getAuthKeyFromRequest = exports.getCustomAttributeFromRequest = exports.setCustomAttributeOnRequest = void 0;
const backend_1 = require("@clerk/backend");
const server_1 = require("next/server");
function setCustomAttributeOnRequest(req, key, value) {
    Object.assign(req, { [key]: value });
}
exports.setCustomAttributeOnRequest = setCustomAttributeOnRequest;
function getCustomAttributeFromRequest(req, key) {
    // @ts-expect-error
    return key in req ? req[key] : undefined;
}
exports.getCustomAttributeFromRequest = getCustomAttributeFromRequest;
function getAuthKeyFromRequest(req, key) {
    return (getCustomAttributeFromRequest(req, backend_1.constants.Attributes[key]) ||
        getHeader(req, backend_1.constants.Headers[key]) ||
        (key === 'AuthStatus' ? getQueryParam(req, backend_1.constants.SearchParams.AuthStatus) : undefined));
}
exports.getAuthKeyFromRequest = getAuthKeyFromRequest;
// Tries to extract auth status from the request using several strategies
// TODO: Rename Auth status and align the naming across media
function getAuthStatusFromRequest(req) {
    return (getCustomAttributeFromRequest(req, backend_1.constants.Attributes.AuthStatus) ||
        getHeader(req, backend_1.constants.Headers.AuthStatus) ||
        getQueryParam(req, backend_1.constants.SearchParams.AuthStatus));
}
exports.getAuthStatusFromRequest = getAuthStatusFromRequest;
function getQueryParam(req, name) {
    if (isNextRequest(req)) {
        return req.nextUrl.searchParams.get(name);
    }
    // Check if the request contains a parsed query object
    // NextApiRequest does, but the IncomingMessage in the GetServerSidePropsContext case does not
    let queryParam;
    if ('query' in req) {
        queryParam = req.query[name];
    }
    // Fall back to query string
    if (!queryParam) {
        const qs = (req.url || '').split('?')[1];
        queryParam = new URLSearchParams(qs).get(name);
    }
    return queryParam;
}
function getHeader(req, name) {
    if (isNextRequest(req)) {
        return req.headers.get(name);
    }
    // If no header has been determined for IncomingMessage case, check if available within private `socket` headers
    // When deployed to vercel, req.headers for API routes is a `IncomingHttpHeaders` key-val object which does not follow
    // the Headers spec so the name is no longer case-insensitive.
    return req.headers[name] || req.headers[name.toLowerCase()] || req.socket?._httpMessage?.getHeader(name);
}
exports.getHeader = getHeader;
function getCookie(req, name) {
    if (isNextRequest(req)) {
        // Nextjs broke semver in the 13.0.0 -> 13.0.1 release, so even though
        // this should be RequestCookie in all updated apps. In order to support apps
        // using v13.0.0 still, we explicitly add the string type
        // https://github.com/vercel/next.js/pull/41526
        const reqCookieOrString = req.cookies.get(name);
        if (!reqCookieOrString) {
            return undefined;
        }
        return typeof reqCookieOrString === 'string' ? reqCookieOrString : reqCookieOrString.value;
    }
    return req.cookies[name];
}
exports.getCookie = getCookie;
function isNextRequest(val) {
    try {
        const { headers, nextUrl, cookies } = (val || {});
        return (typeof headers?.get === 'function' &&
            typeof nextUrl?.searchParams.get === 'function' &&
            typeof cookies?.get === 'function');
    }
    catch (e) {
        return false;
    }
}
const OVERRIDE_HEADERS = 'x-middleware-override-headers';
const MIDDLEWARE_HEADER_PREFIX = 'x-middleware-request';
const setRequestHeadersOnNextResponse = (res, req, newHeaders) => {
    if (!res.headers.get(OVERRIDE_HEADERS)) {
        // Emulate a user setting overrides by explicitly adding the required nextjs headers
        // https://github.com/vercel/next.js/pull/41380
        // @ts-expect-error
        res.headers.set(OVERRIDE_HEADERS, [...req.headers.keys()]);
        req.headers.forEach((val, key) => {
            res.headers.set(`${MIDDLEWARE_HEADER_PREFIX}-${key}`, val);
        });
    }
    // Now that we have normalised res to include overrides, just append the new header
    Object.entries(newHeaders).forEach(([key, val]) => {
        res.headers.set(OVERRIDE_HEADERS, `${res.headers.get(OVERRIDE_HEADERS)},${key}`);
        res.headers.set(`${MIDDLEWARE_HEADER_PREFIX}-${key}`, val);
    });
};
exports.setRequestHeadersOnNextResponse = setRequestHeadersOnNextResponse;
/**
 * Test whether the currently installed nextjs version supports overriding the request headers.
 * This feature was added in nextjs v13.0.1
 * https://github.com/vercel/next.js/pull/41380
 */
const nextJsVersionCanOverrideRequestHeaders = () => {
    try {
        const headerKey = 'clerkTest';
        const headerKeyInRes = `${MIDDLEWARE_HEADER_PREFIX}-${headerKey}`;
        const res = server_1.NextResponse.next({ request: { headers: new Headers({ [headerKey]: 'true' }) } });
        return res.headers.has(headerKeyInRes);
    }
    catch (e) {
        return false;
    }
};
exports.nextJsVersionCanOverrideRequestHeaders = nextJsVersionCanOverrideRequestHeaders;
const injectSSRStateIntoObject = (obj, authObject) => {
    // Serializing the state on dev env is a temp workaround for the following issue:
    // https://github.com/vercel/next.js/discussions/11209|Next.js
    const __clerk_ssr_state = (process.env.NODE_ENV !== 'production' ? JSON.parse(JSON.stringify({ ...authObject })) : { ...authObject });
    return { ...obj, __clerk_ssr_state };
};
exports.injectSSRStateIntoObject = injectSSRStateIntoObject;
function handleValueOrFn(value, url, defaultValue) {
    if (typeof value === 'function') {
        return value(url);
    }
    if (typeof value !== 'undefined') {
        return value;
    }
    if (typeof defaultValue !== 'undefined') {
        return defaultValue;
    }
    return undefined;
}
exports.handleValueOrFn = handleValueOrFn;
// TODO: use @clerk/shared once it is tree-shakeable
function isHttpOrHttps(key) {
    return /^http(s)?:\/\//.test(key || '');
}
exports.isHttpOrHttps = isHttpOrHttps;
function isDevelopmentFromApiKey(apiKey) {
    return apiKey.startsWith('test_') || apiKey.startsWith('sk_test_');
}
exports.isDevelopmentFromApiKey = isDevelopmentFromApiKey;
